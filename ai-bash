#!/usr/bin/env bash
# ==============================================================================
# EXAMPLES
# ==============================================================================
# ai-bash 'echo $HOME/safe_script.sh >> ~/.bashrc' 'run a command every time a terminal starts, the safe_script.sh just runs a basic date >> ~/login.log for tracking purposes'


# ==============================================================================
# HELP
# ==============================================================================
function usage() {
	cat 1>&2 <<EOF
usage: ai-bash <command> <reason>
  <command>   The command to run
  <reason>    The reason for running the command, uses AI to check for safety

returns:
  { status: <status>, message: <message> }
  <status>    "success" or "error"
  <message>   The output or error message
end

EOF
}

if [[ "$#" -lt 2 ]] || [[ "$1" == "-h" ]] || [[ "$1" == "--help" ]]; then
	usage
	exit 1
fi


# ==============================================================================
# TEMP
# ==============================================================================
stdout_txt="$(mktemp)"
stderr_txt="$(mktemp)"
function cleanup() { rm -rf "$stdout_txt" "$stderr_txt"; }
trap cleanup EXIT


# ==============================================================================
# SAFETY CHECK
# ==============================================================================
reason="$2"

read -r -d '' system_prompt << EOF
You will be given a bash command and must determine if it is safe to execute.

The reason for executing this command is:
<reason>
$reason
</reason>

You must determine if the command is safe to run based on the following criteria:
- The reason must match the command being run.
- Must not be obfuscated or encoded in any way.
- Must not curl then pipe to bash, sh, or any other shell.
- Does not run sudo or require elevated privileges.
- Must not modify any files in any way.
- Does not compromise system security or user data.
- Is not a git push and does not rewrite git history.
- If it might open a pager like git diff, it must disable the pager or pipe to cat.
- Can not be an interactive command.
- Must not install any packages.
- Must not change permissions on any files or directories.

Safe response example: { "status": "success", "message": "Reason command is safe" }
Unsafe response example: { "status": "fail", "message": "This command is unsafe because <reason>" }
EOF

command="$1"

model='azure/gpt-4o'
#model='anthropic/claude-sonnet-4-5-20250929'
response="$(litellm --model "$model" --system-prompt "$system_prompt" "$command")"
status="$(jq -r '.status' <<< "$response")"
message="$(jq -r '.message' <<< "$response")"
if [[ "$status" != "success" ]]; then
	echo "$response"
	exit 0
fi


# ==============================================================================
# RUN
# ==============================================================================
bash -c "$command" >"$stdout_txt" 2>"$stderr_txt"
exit_status=$?


# ==============================================================================
# RESULT
# ==============================================================================
# TODO: Fix output to use status and message fields
jq -n \
	--rawfile stdout "$stdout_txt" \
	--rawfile stderr "$stderr_txt" \
	--argjson exit_status "$exit_status" \
	'{ "stdout": $stdout, "stderr": $stderr, "exit_status": $exit_status }'

