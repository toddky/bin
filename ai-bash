#!/usr/bin/env bash
# ==============================================================================
# HELP
# ==============================================================================
function usage() {
	cat 1>&2 <<EOF
usage: ai-bash <command> <reason>
  <command>   The command to run
  <reason>    The reason for running the command, uses AI to check for safety

returns:
  { status: <status>, message: <message>, stdout: <output>, stderr: <error>, exit_status: <code> }
  <status>    "success" or "fail"
  <message>   The safety assessment or error message
  <stdout>    Command output (if safe and executed)
  <stderr>    Command errors (if safe and executed)
  <exit_status> Command exit code (if safe and executed)
EOF
}

if [[ "$#" -lt 2 ]] || [[ "$1" == "-h" ]] || [[ "$1" == "--help" ]]; then
	usage
	exit 1
fi


# ==============================================================================
# TEMP
# ==============================================================================
stdout_txt="$(mktemp)"
stderr_txt="$(mktemp)"
function cleanup() { rm -rf "$stdout_txt" "$stderr_txt"; }
trap cleanup EXIT


# ==============================================================================
# SAFETY CHECK
# ==============================================================================
reason="$2"
system_info="$(uname -s)"
current_date="$(date)"

read -r -d '' system_prompt << EOF
You will be given a bash command and must determine if it is safe to execute.

The reason for executing this command is:
<reason>
$reason
</reason>

<criteria>
- The reason must match the command being run.
- Must not be obfuscated or encoded in any way.
- Must not curl then pipe to bash, sh, or any other shell.
- Does not run sudo or require elevated privileges.
- Must not modify any files in any way.
- Does not compromise system security or user data.
- Is not a git push and does not rewrite git history.
- If it might open a pager like git diff, it must disable the pager or pipe to cat.
- Can not be an interactive command.
- Must not install any packages.
- Must not change permissions on any files or directories.
</criteria>

<response>
Safe response example: { "status": "success", "message": "Reason command is safe" }
Unsafe response example: { "status": "fail", "message": "This command is unsafe because <reason>" }
</response>

<system_information>
$system_info
</system_information>

<date>
$current_date
</date>
EOF

command="$1"

json_schema='{"type":"object","properties":{"status":{"type":"string","enum":["success","fail"]},"message":{"type":"string"}},"required":["status","message"]}'
response="$(,claude --json-schema "$json_schema" --output-format json --system-prompt "$system_prompt" -p "$command" 2>&1)"
status="$(echo "$response" | jq -r '.structured_output.status // .status' 2>/dev/null)"
message="$(echo "$response" | jq -r '.structured_output.message // .message' 2>/dev/null)"

if [[ "$status" != "success" ]]; then
	echo "$response" | jq -r '.structured_output // .' 2>/dev/null || echo "$response"
	exit 0
fi


# ==============================================================================
# RUN
# ==============================================================================
bash -c "$command" >"$stdout_txt" 2>"$stderr_txt"
exit_status=$?


# ==============================================================================
# RESULT
# ==============================================================================
jq -n \
	--rawfile stdout "$stdout_txt" \
	--rawfile stderr "$stderr_txt" \
	--argjson exit_status "$exit_status" \
	'{status: "success", stdout: $stdout, stderr: $stderr, exit_status: $exit_status}'

