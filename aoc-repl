#!/usr/bin/env bash
# USAGE: aoc-repl
# DESCRIPTION: Run latest executable if it detects a change

# ==============================================================================
# SETUP
# ==============================================================================
# Deeper stack for this error:
# stack level too deep (SystemStackError)
export RUBY_THREAD_VM_STACK_SIZE=10000000

GREEN='\e[32m'
BLUE='\e[37;44;1m'
RESET='\e[0m'


# ==============================================================================
# FUNCTIONS
# ==============================================================================
function getch() {
	stty -icanon time 1 min 0
	char="$(dd bs=1 count=1 2>/dev/null)"
	stty icanon
	echo "$char"
}


# ==============================================================================
# MORE SETUP
# ==============================================================================
[[ -x a.rb ]] && touch a.rb
stty -echo
function atexit() { stty echo; }
trap atexit EXIT


# ==============================================================================
# MAIN
# ==============================================================================
prev_mtime=0
script_args=()
rerun=1

while true; do
	sleep 0.1

	# Get char
	char="$(getch)"
	case "$char" in
		r)     rerun=1; script_args=();;
		0)     rerun=1; script_args=();;
		[1-9]) rerun=1; script_args=("$char");;
		s)     printf ' \n\n'; aoc-repl-submit;;
		q)     break;;
	esac

	# Check if script is done
	if [[ -n "$pid" ]]; then
		if ! kill -0 "$pid" 2>/dev/null; then
			printf "${GREEN}(done)\e[0m\n"
			pid=''
		fi
	fi

	# Get latest file
	latest_file="$(ls -1 -rt ./* ../../todd.rb 2>/dev/null | tail -n 1)"
	[[ -x "$latest_file" ]] && script="$latest_file"
	[[ -x "$script" ]] || continue

	# Get mtime of file
	if [[ "$OSTYPE" =~ .*darwin.* ]]; then
		mtime="$(stat -f %m "$latest_file")"
	else
		mtime="$(stat -c %Y "$latest_file")"
	fi

	if ! ((rerun)); then
		((mtime==prev_mtime)) && continue

		# If the script writes answer.txt, do not trigger a rerun
		[[ "$(basename "$latest_file")" == 'answer.txt' ]] && continue
	fi

	# Kill script if running
	if [[ -n "$pid" ]]; then
		kill "$pid"
		wait "$pid"
	fi

	# Print top header
	width="$(tput cols)"
	height="$(tput lines)"
	printf " \n\ec"
	printf "${BLUE}%0.s " $(seq 1 "$width")
	printf "\r${script}"
	now="$(date +'%Y-%m-%d %T')"
	printf "\r\e[%dC%s\n$RESET" "$((width-19))" "$now"

	# Run
	"$script" "${script_args[@]}" &
	pid="$!"

	# Update results
	prev_mtime="$mtime"
	rerun=0
done

