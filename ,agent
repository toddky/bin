#!/usr/bin/env ruby
# vim: ft=ruby noet ts=4 sw=0 sts

# ==============================================================================
# RESOURCES
# ==============================================================================
# https://github.com/x1xhlol/system-prompts-and-models-of-ai-tools/
# https://cthiriet.com/blog/nano-claude-code
# https://minusx.ai/blog/decoding-claude-code/
# https://www.alephic.com/writing/the-magic-of-claude-code


# ==============================================================================
# REQUIRE
# ==============================================================================
require 'anthropic'
require 'json'
require 'open3'

RESET = "\e[0m"
BOLD  = "\e[1m"
RED   = "\e[31m"
GREEN = "\e[38;5;46m"
BLUE  = "\e[38;5;51m"
GRAY  = "\e[90m"


# ==============================================================================
# SYSTEM PROMPT
# ==============================================================================
SYSTEM_PROMPT = <<-EOF
<tone>
- Cut out filler and polite fluff
- Be functional and task-oriented, not engaging. Like speaking to an engineer
</tone>

When printing code, use this format:
```language
code here
```

IMPORTANT: DO NOT CREATE FILES UNLESS EXPLICITLY INSTRUCTED TO DO SO.
EOF


# ==============================================================================
# TOOLS
# ==============================================================================
tools = [
	{
		name: "quit",
		description: "Exit the chat",
		input_schema: {
			type: "object",
		}
	},
	{
		name: "read_file",
		description: "Read contents of a file from the filesystem",
		input_schema: {
			type: "object",
			properties: {
				file_path: { type: "string", description: "Path to the file to read" }
			},
			required: ["file_path"]
		}
	},
	{
		name: "write_file",
		description: "Write contents to a file on the filesystem",
		input_schema: {
			type: "object",
			properties: {
				file_path: { type: "string", description: "Path to the file to write" },
				text:      { type: "string", description: "Text to write to the file" }
			},
			required: ["file_path", "text"]
		}
	},
	{
		name: "bash",
		description: "Execute a bash command on the system",
		input_schema: {
			type: "object",
			properties: {
				command: { type: "string", description: "The bash command to execute" },
				reason:  { type: "string", description: "The reason for executing this command. This will be used to determine if the command is safe." }
			},
			required: ["command"]
		}
	}
]

def quit(input)
	exit
end

def read_file(input)
	file_path = input["file_path"]
	begin
		content = File.read(file_path)
		return {status: "success", content: content}
	rescue Errno::ENOENT
		return {status: "error", message: "File not found"}
	rescue => e
		return {status: "error", message: e.message}
	end
end

def write_file(input)
	file_path = input["file_path"]
	if File.exist? file_path
		return {status: 'error', message: "File already exists, editing files not supported yet"}
	end

	system_prompt = <<-EOF
	You will be given a file path and must determine if it is safe to write to that file.
	Consider the following:
	- The file path must be within a safe directory
	- Avoid system directories like /etc, /bin, /usr, /var, or /lib
	- Avoid sensitive extensions like .key, .pem, or .env
	- Avoid configuration files like .bashrc, .vimrc, or .gitconfig
	- Avoid user home directories like /home/user/.ssh or /home/user/.config
	- Avoid hidden files or directories

	Safe response example: { "safe": true }
	Unsafe response example: { "safe": false, "reason": "explanation" }
	EOF

	prompt = File.expand_path(file_path)
	response = ask_json(prompt, system_prompt)

	safe = response['safe'] || false
	if not safe then
		reason = response['reason'] || 'Unknown reason'
		return {status: 'error', message: "Unsafe file path: #{reason}"}
	end

	text = input["text"]
	begin
		File.write(file_path, text)
		return {status: "success", message: "File written successfully"}
	rescue => e
		return {status: "error", message: e.message}
	end
end

def bash(input)

	command = input["command"]
	reason  = input["reason"] || "No reason provided"

	# Safety check
	system_prompt = <<-EOF
	You will be given a bash command and must determine if it is safe to execute.

	The reason for executing this command is:
	<reason>
	#{reason}
	</reason>

	You must determine if the command is safe to run based on the following criteria:
	- The reason must match the command being run.
	- Must not be obfuscated or encoded in any way.
	- Must not curl then pipe to bash, sh, or any other shell.
	- Does not run sudo or require elevated privileges.
	- Must not modify any files in any way.
	- Does not compromise system security or user data.
	- Is not a git push and does not rewrite git history.
	- If it might open a pager like git diff, it must disable the pager or pipe to cat.
	- Can not be an interactive command.
	- Must not install any packages.
	- Must not change permissions on any files or directories.

	Safe response example: { "safe": true }
	Unsafe response example: { "safe": false, "reason": "explanation" }
	EOF


	response = ask_json(command, system_prompt)

	safe = response['safe'] || false
	if not safe then
		reason = response['reason'] || 'Unknown reason'
		return {status: 'error', message: "Unsafe command: #{reason}"}
	end

	# Run command
	stdout, stderr, status = Open3.capture3("bash", "-c", command)

	# Return resultz
	status = status.exitstatus == 0 ? 'success' : 'error'
	message = ''
	message += 'STDOUT:'
	message += (stdout && !stdout.empty?) ? "\n#{stdout}\n" : " <no output>\n"
	message += 'STDERR:'
	message += (stderr && !stderr.empty?) ? "\n#{stderr}\n" : " <no output>\n"
	return { status: status, message: message }
end


# ==============================================================================
# CALL TOOL
# ==============================================================================
def call_tool(content)
	name = content.name
	input = content.input.empty? ? {} : JSON.parse(content.input)

	shortened_input = {}
	input.each do |k,v|
		if v.is_a?(String) and v.length > 80
			v = v[0..70] + "<...SNIP...>"
		end
		shortened_input[k] = v
	end

	puts "#{BLUE}🔧 #{name}#{RESET} #{shortened_input}"
	tool_use_message = {
		role: "assistant", content: [
		{
			type: "tool_use",
			id: content.id,
			name: content.name,
			input: input,
		}
	]}

	result = send(name, input)
	result = {status: "error", message: "Tool returned no result"} if result.nil?

	if result[:status] != "success"
		$stderr.puts "#{RED}❌ #{result[:message]}#{RESET}"
	end

	tool_result_message = {
		role: "user",
		content: [
			{
				type: "tool_result",
				tool_use_id: content.id,
				content: result.to_json,
			}
		]
	}

	return tool_use_message, tool_result_message
end


# ==============================================================================
# ASK
# ==============================================================================
def ask(prompt, system_prompt = nil)
	max_tokens = 4096
	api_key    = ENV["ANTHROPIC_AUTH_TOKEN"],
	base_url   = ENV["ANTHROPIC_BASE_URL"]
	model      = ENV["ANTHROPIC_MODEL"]

	anthropic = Anthropic::Client.new(
		api_key: api_key,
		base_url: base_url,
	)

	messages = [{role: "user", content: prompt}]
	response = anthropic.messages.create(
		max_tokens: max_tokens,
		system:     system_prompt,
		messages:   messages,
		model:      model,
	)
	return response
end
#response = ask('In one sentence, tell me what is the meaning of life.')
#puts response.content[0].text
#exit

def ask_json(prompt, system_prompt = '', retries = 3)

	important = 'IMPORTANT: YOUR RESPONSE MUST BE VALID JSON. ONLY RESPOND WITH JSON. DO NOT ADD MARKDOWN FORMATTING.'
	system_prompt = "#{system_prompt}\n\n#{important}"

	responses = []
	while retries > 0
		response = ask(prompt, system_prompt)
		begin
			json = JSON.parse(response.content[0].text)
			return json
		rescue JSON::ParserError => e
			responses << response.content[0].text
			retries -= 1
		end
	end

	$stderr.puts "\nERROR: Failed to parse JSON response after multiple attempts."
	$stderr.puts "Responses received:"
	responses.each_with_index do |resp, idx|
		$stderr.puts "Attempt #{idx + 1}: #{resp}"
	end
	exit 1
end


# ==============================================================================
# PRINT
# ==============================================================================
def print_chunk(chunk)
	#print "#{GRAY}(#{chunk.type.inspect})#{RESET}"

	case chunk.type
	when :message_start
		#print '🤖 '
	when :content_block_start
	when :content_block_delta
		if chunk.delta.type == :text_delta
			print chunk.delta.text
			$stdout.flush
		else
			return
			#puts "\nERROR: Unknown delta type: #{chunk.delta.type.inspect}"
			#p chunk.delta
			#exit
		end
	when :text
	when :content_block_stop

	when :input_json
		# TODO
	when :message_delta
		# TODO
	when :message_stop
		 puts
		return chunk.message.content

	else
		puts "\nERROR: Unknown chunk type: #{chunk.type.inspect}"
		p chunk
		exit
	end

	return nil
end


# ==============================================================================
# HELPERS
# ==============================================================================
def get_input()
	# Supports multiline input with 250ms delay
	lines = [STDIN.gets&.chomp]
	while IO.select([STDIN], nil, nil, 0.25)
		lines << STDIN.gets&.chomp
	end
	lines.pop if lines.last&.empty?
	return lines.join("\n")
end


# ==============================================================================
# TESTS
# ==============================================================================
#puts bash({"command" => "echo hello", "reason" => "test"}).to_json; exit


# ==============================================================================
# SETUP
# ==============================================================================
api_key    = ENV["ANTHROPIC_AUTH_TOKEN"],
base_url   = ENV["ANTHROPIC_BASE_URL"]
max_tokens = 4096
model      = ENV["ANTHROPIC_MODEL"]

anthropic = Anthropic::Client.new(
	api_key: api_key,
	base_url: base_url,
)

messages = []


# ==============================================================================
# MAIN
# ==============================================================================
print "#{BOLD}#{RED}"
puts '╭───────────────────────────────────────────────────────────────────────────────╮'
puts "│ TODD CODE (aka Crappy Claude Code)                                            │"
puts '╰───────────────────────────────────────────────────────────────────────────────╯'
print RESET

prev_type = nil
loop do
	if prev_type != :tool_use
		print GREEN
		#print "> "
		print "👤 "
		input = get_input()
		print RESET
		messages << {role: "user", content: input}
	end

	stream = anthropic.messages.stream(
		system: SYSTEM_PROMPT,
		max_tokens: max_tokens,
		messages: messages,
		model: model,
		tools: tools,
	)

	contents = nil
	stream.each do |chunk|
		contents = print_chunk(chunk)
	end

	next if contents.nil?

	contents.each do |content|
		case content.type
		when :text
			messages << {role: "assistant", content: content.text}

		when :tool_use
			tool_use_msg, tool_result_msg = call_tool(content)
			messages << tool_use_msg
			messages << tool_result_msg

		else
			puts "ERROR: Unknown content type: #{content.type.inspect}"
			exit
		end
		prev_type = content.type
	end

	puts "\n"
	#p messages
end

