#!/usr/bin/env bash
SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"

# ==============================================================================
# FUNCTIONS
# ==============================================================================
function append {
	role="$1"
	json_file="$2"
	ruby -e "
		require 'json'
		messages = JSON.parse(File.read(ARGV[1])) + [{'role'=>ARGV[0], 'content'=>STDIN.read.strip}]
		File.write(ARGV[1], messages.to_json)
	" "$role" "$json_file"
}

function call {
	response="$(gum spin --title 'Thinking...' ai-call "$messages" "$tools")"
	retval=$?
	echo "$response"
	return $retval
}


# ==============================================================================
# SETUP
# ==============================================================================
RESET="\e[0m"
GREEN="\e[38;5;46m"

tmpdir="$(mktemp -d)"
messages="$tmpdir/messages.json"
tools="$tmpdir/tools.json"
function cleanup() { rm -rf "$tmpdir"; }
trap cleanup EXIT
echo '[]' > "$messages"

cat > "$tools" <<-EOF
[{
	"name": "quit",
	"description": "Exit the chat",
	"input_schema": {
		"type": "object"
	}
}]
EOF


# ==============================================================================
# MAIN
# ==============================================================================
while true; do
	prompt="$(gum input --prompt 'ðŸ‘¤ ')" || exit
	printf "ðŸ‘¤$GREEN %s$RESET\n" "$prompt"
	append 'user' "$messages" <<<"$prompt"
	#cat "$messages"; exit

	response="$(call)"
	response_type="$(jq -r '.content[0].type' <<<"$response")"
	if [[ "$response_type" == text ]]; then
		text="$(jq -r '.content[0].text' <<<"$response")"
		gum format --theme tokyo-night <<<"$text"
		append 'assistant' "$messages" <<<"$text"
	else
		tool_name="$(jq -r '.content[0].name' <<<"$response")"
		input="$(jq -r '.content[0].input' <<<"$response")"
		gum format --theme tokyo-night "ðŸ› ï¸ $tool_name $input"
		# TODO: Figure out what the tool is actually supposed to do
		exit
	fi
	#cat "$messages"; exi
done

