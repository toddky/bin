#!/usr/bin/env bash
# USAGE: git ai-summarize <SHA>
# DESCRIPTION: Summarize a git commit using AI

commit="${1:-.}"
#[[ -n "$commit" ]] || { print-usage "$(basename "$0") <SHA>" >&2; exit 1; }

# Check for summary.txt
top="$(git-top)" || exit $?
summary_txt="$top/.summary/${commit}.txt"
if [[ -f "$summary_txt" ]]; then
	cat "$summary_txt"
	exit
fi
mkdir -p "$(dirname "$summary_txt")" || exit $?

# System prompt
read -r -d '' system_prompt << EOF
<context>
You will be given the output of \`git show <sha>\`
</context>

<task>
Summarize the entire commit in a single sentence.
Use backticks for code and file names.
</task>

<additional_info>
Just return the commit message, do not include any other text.
If the file is new, say 'new' somewhere in the message.
Unimportant changes do not need to be mentioned.
If the diff is empty, say so.
</additional_info>

<format>
YYYY-MM-DD EMOJI One sentence summary.
</format>

<emojis>
🛠️ for fixes
🚨 for urgent fixes
✨ for new features or quality of life improvements
⚡ for performance optimizations
📝 for documentation or readability
⚙️  for config changes
🚧  for WIP/experimental changes
⏪ for reverts
</emojis>
EOF

# Get commit info
if [[ "$commit" == 'staged' ]]; then
	commit_details="$(git diff --staged)" || exit $?
else
	commit_details="$(git show "$commit")" || exit $?
fi
print-info "Summarizing: ${commit}"
summary="$(ai --system-prompt "$system_prompt" --prompt "$commit_details")" || exit $?
echo "$summary"

# Cache result for commits
 if [[ "$commit" =~ ^[0-9a-fA-F]{7,}$ ]]; then
	echo "$summary" > "$summary_txt"
 fi

