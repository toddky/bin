#!/usr/bin/env bash
# USAGE: git ai-summarize <SHA>
# DESCRIPTION: Summarize a git commit using AI

commit="${1:-.}"
#[[ -n "$commit" ]] || { print-usage "$(basename "$0") <SHA>" >&2; exit 1; }

# Check for summary.txt
top="$(git-top)" || exit $?
summary_txt="$top/.summary/${commit}.txt"
if [[ -f "$summary_txt" ]]; then
	cat "$summary_txt"
	exit
fi
mkdir -p "$(dirname "$summary_txt")" || exit $?

# System prompt
read -r -d '' system_prompt << EOF
<context>
You will be given the output of \`git show <sha>\`
</context>

<task>
Summarize the entire commit in a single sentence.
Use backticks for code and file names.
</task>

<additional_info>
Just return the commit message, do not include any other text.
If the file is new, say 'new' somewhere in the message.
Unimportant changes do not need to be mentioned.
If the diff is empty, say so.
</additional_info>

<format>
YYYY-MM-DD EMOJI One sentence summary.
</format>

<emojis>
ğŸ› ï¸ for fixes
ğŸš¨ for urgent fixes
âœ¨ for new features or quality of life improvements
âš¡ for performance optimizations
ğŸ“ for documentation or readability
âš™ï¸  for config changes
ğŸš§  for WIP/experimental changes
âª for reverts
</emojis>
EOF

# Get commit info
if [[ "$commit" == 'staged' ]]; then
	commit_details="$(git diff --staged)" || exit $?
else
	commit_details="$(git show "$commit")" || exit $?
fi
print-info "Summarizing: ${commit}"
summary="$(ai --system-prompt "$system_prompt" --prompt "$commit_details")" || exit $?
echo "$summary"

# Cache result for commits
 if [[ "$commit" =~ ^[0-9a-fA-F]{7,}$ ]]; then
	echo "$summary" > "$summary_txt"
 fi

