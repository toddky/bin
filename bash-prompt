#!/usr/bin/env bash
# Add the following to your .bashrc:
# ---
# if command -v bash-prompt &>/dev/null; then
# 	PROMPT_COMMAND='PS1="$(RETVAL=$? bash-prompt)"'
# 	export start_ms
# 	function preexec() {
# 		[[ -n "$COMP_LINE" ]] && return
# 		[[ "$BASH_COMMAND" == "$PROMPT_COMMAND" ]] && return
# 		printf "\x1b[38;5;8m[$(date +%T)] Started\e[0m\n"
# 		start_ms="$(date +'%s%3N')"
# 	}
# 	trap 'preexec' DEBUG
# fi

current_ms="$(date +'%s%3N')"

reset="\[\e[0m\]"
red='\[\e[1;31m\]'
green='\[\e[1;32m\]'
yellow='\[\e[1;93m\]'
blue='\[\e[1;34m\]'
magenta='\[\e[1;35m\]'
cyan='\[\e[1;36m\]'
white='\[\e[1;37m\]'

red_bg='\[\e[41m\]'
green_bg='\[\e[42m\]'
yellow_bg='\[\e[43m\]'
blue_bg='\[\e[44m\]'
magenta_bg='\[\e[45m\]'
cyan_bg='\[\e[46m\]'
white_bg='\[\e[47m\]'

# Get exit code of last command
((RETVAL)) && echo "\e[31m(exited $RETVAL)\e[0m"

# Get execution time
if ((start_ms)); then
	printf "\x1b[38;5;8m[$(date +%T)] Finished in "

	# Print seconds
	total_ms=$((current_ms - start_ms))
	ms=$((total_ms % 1000))
	total_s=$((total_ms / 1000))
	printf "%d.%03ds" "$total_s" "$ms"

	# Print hours
	if (( total_s >= 3600 )); then
		h="$(($total_s/3600))"
		printf " (%d.%02d hours)" "$h" "$(((total_s%3600)*100/3600))"
	fi
	printf "\e[0m\n"
fi

# Prompt
prompt=''


# ==============================================================================
# USERNAME
# ==============================================================================
#prompt+="$blue\u"
prompt+="${blue}todd"


# ==============================================================================
# HOST
# ==============================================================================
if [[ ! -e ${TMUX%%,*} ]]; then
	[[ -n $LSB_BATCH_JID ]] && lsf=1 || lsf=0
	[[ $lsf == 1 ]] && prompt+=":$yellow$LSB_BATCH_JID$blue" || prompt+="@\h"
fi


# ==============================================================================
# DIRECTORY
# ==============================================================================
#dir=${PWD%/*/*}
#dir2=${PWD#$dir/}

# Directory permissions
permission=$(stat -c %a .)
p1="${permission:(-3):1}"
p2="${permission:(-2):1}"
p3="${permission:(-1):1}"
prompt+=" "
[[ $(whoami) == $(stat -c %U .) ]] && prompt+="$green$p1" || prompt+="$red$p1"
groups | grep -q $(stat -c %G .)   && prompt+="$green$p2" || prompt+="$red$p2"
prompt+="$green$p3"

# Check PWD for user
pwd | grep -q $(whoami) && prompt+=" $green\W" || prompt+=" $yellow\W"


# ==============================================================================
# GIT
# ==============================================================================
if (git rev-parse --is-inside-work-tree &>/dev/null); then
	#git_url="$(git config --get remote.origin.url 2>/dev/null)"
	git_branch="$(git rev-parse --abbrev-ref HEAD 2>/dev/null)"

	if ! (git diff-index --quiet HEAD 2>/dev/null); then
		prompt+="$red"
	elif ! (git rev-parse @{u} &>/dev/null); then
		prompt+="$cyan"
	else
		prompt+="$green"
	fi
	#prompt+="$white$git_branch$reset"
	prompt+=" $git_branch"

	# TODO: Get ahead/behind
	stat="$(git status -sb -uno 2>/dev/null | head -1)"
	case "$OSTYPE" in
		darwin*)
			ahead="$( echo "$stat" | sed -n -E 's/.*ahead ([0-9]+).*/ +\1/p')"
			behind="$(echo "$stat" | sed -n -E 's/.*behind ([0-9]+).*/ -\1/p')"
		;;
		*)
			ahead="$( echo "$stat" | sed -n 's/.*ahead \([0-9]\+\).*/ +\1/p')"
			behind="$(echo "$stat" | sed -n 's/.*behind \([0-9]\+\).*/ -\1/p')"
		;;
	esac
	prompt+="$yellow$ahead"
	prompt+="$red$behind"
fi


# ==============================================================================
# END
# ==============================================================================
# Check last command
#if [[ -n "$RETVAL" ]]; then
	#[[ $RETVAL == 0 ]] && prompt+=" $green:)" || prompt+=" $red:("
#fi
prompt_char='$'
prompt_char='»'
#prompt_char='≫'
#prompt_char='⪢'
#prompt_char='▶'
#prompt+=" $cyan$prompt_char$reset "
#prompt+=" $yellow$prompt_char$reset "
prompt+=" $blue$prompt_char$reset "

echo "$prompt"

